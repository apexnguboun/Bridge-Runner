# -*- coding: utf-8 -*-
"""gamee3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ozmyEInBn-8mBf9xEaFUkxHt_Y8HtOIJ
"""

from ursina import *
import random, math, time

app = Ursina()
window.exit_button.visible = True
window.fps_counter.enabled = False
window.entity_counter.enabled = False
window.collider_counter.enabled = False


# ===================== ‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏â‡∏≤‡∏Å =====================
START_SIZE   = 40
GOAL_SIZE    = 20
GAP_START_Z  = START_SIZE/2
GAP_END_Z    = 70
GOAL_Z       = GAP_END_Z + GOAL_SIZE/2

SPAWN_INTERVAL = 3.5
PLAYER_LANE_X  = -2
BOT_LANE_X     =  2
BLOCK_Y        = 0.5
STEP_RISE      = 0.03
GRID           = 1.0

def floor_snap(v, g=1.0):
    return math.floor(v/g)*g


# ===================== ‡∏ï‡∏±‡∏ß‡∏ß‡∏¥‡πà‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô =====================
class Runner(Entity):
    def __init__(self, lane_x, color_main, **kwargs):
        super().__init__(model='cube',
                         origin_y=-0.5, collider='box',
                         scale=(1,1,1), color=color.clear, **kwargs)
        
        
        # ---- ‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏à‡∏£‡∏¥‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏•‡∏π‡∏Å (visual) ----
        self.visual = Entity(
            parent=self,
            model='assets/models/player/blue.obj',
            texture='textures/player/colormap.png',
            scale=2.25,
            y=1,   # ‡∏õ‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏î‡∏±‡∏ö‡πÄ‡∏ó‡πâ‡∏≤
            z=0.2,  # ‚úÖ ‡∏ä‡∏î‡πÄ‡∏ä‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏¢‡∏∑‡πâ‡∏≠‡∏á‡πÅ‡∏Å‡∏ô Z
            color=color_main
        )

        self.speed = 9
        self.jump_force = 7.5
        self.gravity = 22
        self.vel_y = 0
        self.inventory = 0
        self.lane_x = lane_x
        self.color_main = color_main
        self._stack = []
        self.safe_z = None
        self.finished = False

                # ===== ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÅ‡∏≠‡∏ô‡∏¥‡πÄ‡∏°‡∏ä‡∏±‡∏ô =====
        self.walk_phase = 0
        self.is_moving = False

    def on_ground(self):
        return raycast(self.world_position + Vec3(0,0.1,0), Vec3(0,-1,0),
                       distance=0.35, ignore=[self]).hit

    def move_input(self):
        if self.finished:
            return Vec3(0,0,0)
        v = Vec3(0,0,0)
        if held_keys['w']: v.z += 1
        if held_keys['s']: v.z -= 1
        if held_keys['a']: v.x -= 1
        if held_keys['d']: v.x += 1
        return v.normalized() if v.length() else v

    def physics_update(self, mv):
        if self.finished:
            return
        self.is_moving = mv.length() > 0
        if mv.length() > 0:
            self.position += mv * self.speed * time.dt
            self.rotation_y = math.degrees(math.atan2(mv.x, mv.z))
        if self.on_ground():
            self.vel_y = self.jump_force if held_keys['space'] else max(0, self.vel_y)
        else:
            self.vel_y -= self.gravity * time.dt
        self.y += self.vel_y * time.dt
        self.animate_visual_movement(self.is_moving)
        if GAP_START_Z-0.01 <= self.z <= GAP_END_Z+0.01:
            self.x = lerp(self.x, self.lane_x, min(1, time.dt*10))

    def animate_visual_movement(self, moving: bool):
        if not hasattr(self, 'visual'):
            return

        if moving:
            self.walk_phase += time.dt * 8  # ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡∏ß‡πà‡∏á

            # ‡πÅ‡∏Å‡∏ß‡πà‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏ö‡∏≤ ‡πÜ (‡∏ã‡πâ‡∏≤‡∏¢‚Äì‡∏Ç‡∏ß‡∏≤)
            self.visual.rotation_z = math.sin(self.walk_phase) * 3

            # ‡πÄ‡∏î‡πâ‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡∏•‡∏á‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
            target_y = -0.5 + abs(math.sin(self.walk_phase * 0.5)) * 0.05
            self.visual.y = lerp(self.visual.y, target_y, time.dt * 8)

        else:
            # ‡∏Å‡∏•‡∏±‡∏ö‡∏ó‡πà‡∏≤‡∏õ‡∏Å‡∏ï‡∏¥‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡∏∏‡πà‡∏°‡∏ô‡∏ß‡∏•
            self.visual.rotation_z = lerp(self.visual.rotation_z, 0, time.dt * 6)
            self.visual.y = lerp(self.visual.y, -0.5, time.dt * 6)
        
        target_y = 1 + abs(math.sin(self.walk_phase * 0.5)) * 0.05
        self.visual.y = lerp(self.visual.y, target_y, time.dt * 8)


    def _update_stack_visual(self):
        for e in self._stack: destroy(e)
        self._stack.clear()
        for i in range(self.inventory):
            self._stack.append(
                Entity(parent=self, texture='assets/brick.png',model='cube', color=self.color_main,
                       scale=Vec3(1,0.30,1), position=Vec3(0,0.6+i*0.23,-0.5))
            )

    def add_block(self, n=1):
        self.inventory += n
        self._update_stack_visual()

    def consume_block(self, n=1):
        self.inventory = max(0, self.inventory - n)
        self._update_stack_visual()


# ===================== ‡∏ö‡∏≠‡∏ó =====================
class Bot(Runner):
    LOAD_TARGET = 8
    EDGE_Z      = GAP_START_Z - 0.6

    def __init__(self, lane_x, color_main, **kwargs):
        super().__init__(lane_x=lane_x, color_main=color_main, **kwargs)

        self.visual.model = 'assets/models/player/red.obj'
        self.visual.color = color_main
        self.visual.z = 0.2  # ‚úÖ ‡∏õ‡∏£‡∏±‡∏ö offset z ‡πÉ‡∏´‡πâ‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
        self.visual.y = -0.2
        self.speed = 8.5

    def ai_move(self, level):
        if self.finished:
            return Vec3(0,0,0)
        if self.z >= GOAL_Z - GOAL_SIZE/2:
            self.finished = True
            self.rotation_y = 0
            return Vec3(0,0,0)
        if GAP_START_Z - 0.6 <= self.z <= GAP_END_Z + 0.4:
            self.x = lerp(self.x, self.lane_x, min(1, time.dt*20))
            self.rotation_y = 0
            if self.inventory > 0:
                return Vec3(0,0,1)
            if self.inventory == 0 and self.z >= GAP_END_Z - 1.0:
                self.y = lerp(self.y, 1.0, time.dt*5)
                goal_target = Vec3(self.lane_x, 1, GOAL_Z)
                v = goal_target - self.position; v.y = 0
                if v.length() > 0:
                    self.rotation_y = 0
                    return v.normalized()
                return Vec3(0,0,0)
            back_target = Vec3(self.lane_x, 0.5, self.EDGE_Z)
            v = back_target - self.position; v.y = 0
            if v.length() > 0:
                self.rotation_y = 180
                return v.normalized()
            return Vec3(0,0,0)
        if self.z <= GAP_START_Z - 0.25:
            mine = [b for b in level.collectables if b.color == self.color_main]
            if self.inventory < self.LOAD_TARGET and mine:
                target = min(mine, key=lambda b: distance_2d(Vec2(self.x,self.z), Vec2(b.x,b.z)))
                v = target.position - self.position; v.y = 0
                if v.length() > 0:
                    self.rotation_y = math.degrees(math.atan2(v.x, v.z))
                    return v.normalized()
                return Vec3(0,0,0)
            edge_target = Vec3(self.lane_x, 0.5, GAP_START_Z - 0.1)
            v = edge_target - self.position; v.y = 0
            if v.length() > 0:
                self.rotation_y = 0
                return v.normalized()
            return Vec3(0,0,0)
        self.x = lerp(self.x, self.lane_x, min(1, time.dt*10))
        v = Vec3(self.lane_x, 0.5, GAP_START_Z) - self.position; v.y = 0
        if v.length() > 0:
            self.rotation_y = math.degrees(math.atan2(v.x, v.z))
            return v.normalized()
        return Vec3(0,0,0)


# ===================== ‡πÄ‡∏•‡πÄ‡∏ß‡∏•‡∏´‡∏•‡∏±‡∏Å =====================
class BridgeRaceLevel(Entity):
    def __init__(self):
        super().__init__()
        
        self.start_island = Entity(model='cube', scale=(START_SIZE,1,START_SIZE),texture='assets/floor',
                                   color=color.white, collider='box', position=(0,0,0))
        self.goal_island = Entity(model='cube', scale=(GOAL_SIZE,1,GOAL_SIZE),
                                  color=color.green, collider='box', position=(0,0.5,GOAL_Z))
        Entity(model='assets/models/map/flag.obj', texture='assets/textures/map/colormap.png' , rotation_y=60,scale=(7), position=(0,2,GOAL_Z))
        Entity(model='cube', color=color.azure,
               scale=(1,0.3,1), position=(-2,0.2,20), collider='box')
        Entity(model='cube', color=color.red,
               scale=(1,0.3,1), position=(2,0.2,20), collider='box')
    
        self.player = Runner(PLAYER_LANE_X, color.azure, position=Vec3(PLAYER_LANE_X,1,-START_SIZE/4))
        self.bot = Bot(BOT_LANE_X, color.red, position=Vec3(BOT_LANE_X,1,-START_SIZE/4))
        camera.fov = 60
        camera.position = Vec3(0,25,-40)
        camera.rotation_x = 25
        self.collectables = []
        for _ in range(12): self.spawn_block()
        invoke(self.spawn_block, delay=SPAWN_INTERVAL)
        self.player_bridge, self.bot_bridge = [], []
        self.player_text = Text(text='You: 0', position=Vec2(-0.47,0.45))
        self.bot_text    = Text(text='Bot: 0',  position=Vec2(0.33,0.45))
        self.win_text = None
        # ================== üå§Ô∏è ‡πÅ‡∏™‡∏á‡πÅ‡∏•‡∏∞‡πÄ‡∏á‡∏≤ ==================
        # ‡πÅ‡∏™‡∏á‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå‡∏´‡∏•‡∏±‡∏Å
        sun = DirectionalLight()
        sun.look_at(Vec3(1, -1, -0.5))      # ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡πÅ‡∏™‡∏á‡πÄ‡∏â‡∏µ‡∏¢‡∏á‡∏•‡∏á
        sun.color = color.rgb(255, 245, 220)
        sun.shadows = True                   # ‚úÖ ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏á‡∏≤
        sun.shadow_map_resolution = (2048, 2048)
        sun.shadow_bias = 0.0005

        # ‡πÅ‡∏™‡∏á‡∏£‡∏≠‡∏ö‡∏â‡∏≤‡∏Å (ambient) ‡πÉ‡∏´‡πâ‡∏™‡πà‡∏ß‡∏ô‡∏°‡∏∑‡∏î‡πÑ‡∏°‡πà‡∏î‡∏≥‡∏™‡∏ô‡∏¥‡∏ó
        ambient = AmbientLight()
        ambient.color = color.rgb(100, 100, 120)

        # ‡∏ñ‡πâ‡∏≤‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£‡∏´‡∏£‡∏∑‡∏≠‡∏û‡∏∑‡πâ‡∏ô‡πÑ‡∏°‡πà‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏≤ ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡∏¥‡∏î‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏á‡πÅ‡∏ö‡∏ö‡∏ô‡∏µ‡πâ‡∏î‡πâ‡∏ß‡∏¢
        for e in scene.entities:
            if hasattr(e, 'model'):
                e.model = e.model  # ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡∏£‡∏µ‡πÇ‡∏´‡∏•‡∏î model ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏≤
        
        sky = Sky()

    def spawn_block(self):
        col = random.choice([color.azure, color.red])
        x = random.randint(-int(START_SIZE/2)+1, int(START_SIZE/2)-1)
        z = random.randint(-int(START_SIZE/2)+1, int(START_SIZE/2)-1)
        self.collectables.append(Entity(model='cube', texture='assets/brick.png',color=col, scale=(1,0.5,1), position=(x,BLOCK_Y,z), collider='box'))
        invoke(self.spawn_block, delay=SPAWN_INTERVAL)

    def try_pickup_blocks(self, r: Runner):
        for b in list(self.collectables):
            if b.color != r.color_main: continue
            if distance(r.position, b.position) < 1.4 and r.z <= GAP_START_Z + 0.01:
                self.collectables.remove(b); destroy(b); r.add_block(1); break

    def ensure_bridge(self, r: Runner, bridge_list: list):
        FIRST_Z = GAP_START_Z - 0.5
        if not (GAP_START_Z-2.0 <= r.z <= GAP_END_Z+0.6): return
        last_z = max([p.position.z for p in bridge_list], default=FIRST_Z - GRID)
        if r.inventory > 0:
            front_target = max(FIRST_Z, floor_snap(r.z, GRID)) + 0.5
            z = max(last_z, FIRST_Z) + GRID
            while z <= min(front_target, GAP_END_Z) and r.inventory > 0:
                step_idx = int(round((z - FIRST_Z)/GRID))
                y = BLOCK_Y + step_idx * STEP_RISE
                pos = Vec3(r.lane_x, y, z)
                exists = any(abs(e.position.x-pos.x)<0.05 and abs(e.position.z-pos.z)<0.05 for e in bridge_list)
                if not exists:
                    piece = Entity(model='cube',texture='assets/brick.png', color=r.color_main.tint(-.15),
                                   scale=(1,0.3,1), position=pos, collider='box')
                    bridge_list.append(piece)
                    r.consume_block(1)
                    r.safe_z = z
                z += GRID
        if r.inventory == 0 and r.safe_z is not None and r.z > r.safe_z:
            r.z = r.safe_z
            r.vel_y = 0
        if bridge_list:
            last_piece = max(bridge_list, key=lambda e: e.position.z)
            if GAP_START_Z-0.6 <= r.z <= last_piece.z + 0.3:
                r.y = max(r.y, last_piece.y + 1)

    def reset_if_fall(self, r: Runner):
        if r.y < -7.5 and r.z < GAP_END_Z:
            r.position = Vec3(r.lane_x, 1, -START_SIZE/4)
            r.vel_y = 0

    def update(self):
        if self.win_text:
            self.player.finished = True
            self.bot.finished = True
            return
        self.player.physics_update(self.player.move_input())
        self.try_pickup_blocks(self.player)
        self.ensure_bridge(self.player, self.player_bridge)
        self.reset_if_fall(self.player)
        self.bot.physics_update(self.bot.ai_move(self))
        self.try_pickup_blocks(self.bot)
        self.ensure_bridge(self.bot, self.bot_bridge)
        self.reset_if_fall(self.bot)
        cam_target = self.player.position + Vec3(0,20,-30)
        camera.position = lerp(camera.position, cam_target, time.dt*3)
        camera.look_at(self.player.position + Vec3(0,4,0))
        self.player_text.text = f'You: {self.player.inventory}'
        self.bot_text.text    = f'Bot: {self.bot.inventory}'
        if not self.win_text:
            if distance(self.player.position, self.goal_island.position) < GOAL_SIZE/2:
                self.win_text = Text('YOU WIN!', origin=(0,0), scale=3, color=color.gold)
                self.player.finished = True
                self.bot.finished = True
                return
            elif self.bot.z >= GAP_END_Z - 0.3:
                self.win_text = Text('YOU LOSE!', origin=(0,0), scale=3, color=color.red)
                self.player.finished = True
                self.bot.finished = True
                self.bot.z = GAP_END_Z - 0.3
                return


# ===================== ‡∏Ñ‡∏±‡∏ó‡∏ã‡∏µ‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏° =====================
def start_cutscene():
    bg = Entity( model='quad',
                texture='assets/bg.png',  
                scale=(22),                   
                z=10,                               
                color=color.white  )
    red_block = Entity(model='assets/models/player/red.obj',texture='textures/player/colormap.png',color=color.red, scale=(3.5), position=(-4,-1.5,2), rotation_y=-225)
    blue_block = Entity(model='assets/models/player/blue.obj',texture='textures/player/colormap.png', color=color.azure, scale=(3.5), position=(4,-1.5,2), rotation_y=225)
    start_button = Button(model='quad',texture= 'assets/start' ,scale=(0.35), color=color.white, y=-0.1)
    logo = Entity(model='quad',        
                texture='assets/logo.png',
                scale=(5),     
                position=(0, 2.1)  )

    def start_game():
        destroy(red_block)
        destroy(blue_block)
        destroy(start_button)
        destroy(logo)
        destroy(bg)
        BridgeRaceLevel()
    start_button.on_click = start_game

start_cutscene()
app.run()