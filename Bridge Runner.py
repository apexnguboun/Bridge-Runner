# -*- coding: utf-8 -*-
"""gamee3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ozmyEInBn-8mBf9xEaFUkxHt_Y8HtOIJ
"""

from ursina import *
import random, math, time

app = Ursina()
window.exit_button.visible = True
window.fps_counter.enabled = False
window.entity_counter.enabled = False
window.collider_counter.enabled = False


# ===================== พารามิเตอร์ฉาก =====================
START_SIZE   = 40
GOAL_SIZE    = 20
GAP_START_Z  = START_SIZE/2
GAP_END_Z    = 70
GOAL_Z       = GAP_END_Z + GOAL_SIZE/2

SPAWN_INTERVAL = 3.5
PLAYER_LANE_X  = -2
BOT_LANE_X     =  2
BLOCK_Y        = 0.5
STEP_RISE      = 0.03
GRID           = 1.0

def floor_snap(v, g=1.0):
    return math.floor(v/g)*g


# ===================== ตัววิ่งพื้นฐาน =====================
class Runner(Entity):
    def __init__(self, lane_x, color_main, **kwargs):
        super().__init__(model='cube',
                         origin_y=-0.5, collider='box',
                         scale=(1,2,1), color=color.clear, **kwargs)
        
        
        # ---- โมเดลจริงเป็นลูก (visual) ----
        self.visual = Entity(
            parent=self,
            model='assets/models/player/blue.obj',
            texture='textures/player/colormap.png',
            scale=2.25,
            y=-0.2,   # ปรับระดับเท้า
            z=0.2,  # ✅ ชดเชยการเยื้องแกน Z
            color=color_main
        )

        self.speed = 9
        self.jump_force = 7.5
        self.gravity = 22
        self.vel_y = 0
        self.inventory = 0
        self.lane_x = lane_x
        self.color_main = color_main
        self._stack = []
        self.safe_z = None
        self.finished = False

    def on_ground(self):
        return raycast(self.world_position + Vec3(0,0.1,0), Vec3(0,-1,0),
                       distance=0.35, ignore=[self]).hit

    def move_input(self):
        if self.finished:
            return Vec3(0,0,0)
        v = Vec3(0,0,0)
        if held_keys['w']: v.z += 1
        if held_keys['s']: v.z -= 1
        if held_keys['a']: v.x -= 1
        if held_keys['d']: v.x += 1
        return v.normalized() if v.length() else v

    def physics_update(self, mv):
        if self.finished:
            return
        if mv.length() > 0:
            self.position += mv * self.speed * time.dt
            self.rotation_y = math.degrees(math.atan2(mv.x, mv.z))
        if self.on_ground():
            self.vel_y = self.jump_force if held_keys['space'] else max(0, self.vel_y)
        else:
            self.vel_y -= self.gravity * time.dt
        self.y += self.vel_y * time.dt
        if GAP_START_Z-0.01 <= self.z <= GAP_END_Z+0.01:
            self.x = lerp(self.x, self.lane_x, min(1, time.dt*10))

    def _update_stack_visual(self):
        for e in self._stack: destroy(e)
        self._stack.clear()
        for i in range(self.inventory):
            self._stack.append(
                Entity(parent=self, model='cube', color=self.color_main,
                       scale=Vec3(1,0.30,1), position=Vec3(0,0.6+i*0.23,-0.5))
            )

    def add_block(self, n=1):
        self.inventory += n
        self._update_stack_visual()

    def consume_block(self, n=1):
        self.inventory = max(0, self.inventory - n)
        self._update_stack_visual()


# ===================== บอท =====================
class Bot(Runner):
    LOAD_TARGET = 8
    EDGE_Z      = GAP_START_Z - 0.6

    def __init__(self, lane_x, color_main, **kwargs):
        super().__init__(lane_x=lane_x, color_main=color_main, **kwargs)

        self.visual.model = 'assets/models/player/red.obj'
        self.visual.color = color_main
        self.visual.z = 0.2  # ✅ ปรับ offset z ให้เท่ากับผู้เล่น
        self.visual.y = -0.2
        self.speed = 8.5

    def ai_move(self, level):
        if self.finished:
            return Vec3(0,0,0)
        if self.z >= GOAL_Z - GOAL_SIZE/2:
            self.finished = True
            self.rotation_y = 0
            return Vec3(0,0,0)
        if GAP_START_Z - 0.6 <= self.z <= GAP_END_Z + 0.4:
            self.x = lerp(self.x, self.lane_x, min(1, time.dt*20))
            self.rotation_y = 0
            if self.inventory > 0:
                return Vec3(0,0,1)
            if self.inventory == 0 and self.z >= GAP_END_Z - 1.0:
                self.y = lerp(self.y, 1.0, time.dt*5)
                goal_target = Vec3(self.lane_x, 1, GOAL_Z)
                v = goal_target - self.position; v.y = 0
                if v.length() > 0:
                    self.rotation_y = 0
                    return v.normalized()
                return Vec3(0,0,0)
            back_target = Vec3(self.lane_x, 0.5, self.EDGE_Z)
            v = back_target - self.position; v.y = 0
            if v.length() > 0:
                self.rotation_y = 180
                return v.normalized()
            return Vec3(0,0,0)
        if self.z <= GAP_START_Z - 0.25:
            mine = [b for b in level.collectables if b.color == self.color_main]
            if self.inventory < self.LOAD_TARGET and mine:
                target = min(mine, key=lambda b: distance_2d(Vec2(self.x,self.z), Vec2(b.x,b.z)))
                v = target.position - self.position; v.y = 0
                if v.length() > 0:
                    self.rotation_y = math.degrees(math.atan2(v.x, v.z))
                    return v.normalized()
                return Vec3(0,0,0)
            edge_target = Vec3(self.lane_x, 0.5, GAP_START_Z - 0.1)
            v = edge_target - self.position; v.y = 0
            if v.length() > 0:
                self.rotation_y = 0
                return v.normalized()
            return Vec3(0,0,0)
        self.x = lerp(self.x, self.lane_x, min(1, time.dt*10))
        v = Vec3(self.lane_x, 0.5, GAP_START_Z) - self.position; v.y = 0
        if v.length() > 0:
            self.rotation_y = math.degrees(math.atan2(v.x, v.z))
            return v.normalized()
        return Vec3(0,0,0)


# ===================== เลเวลหลัก =====================
class BridgeRaceLevel(Entity):
    def __init__(self):
        super().__init__()
        
        self.start_island = Entity(model='plane', scale=(START_SIZE,1,START_SIZE),
                                   texture='white_cube', texture_scale=(START_SIZE,START_SIZE),
                                   color=color.white, collider='box', position=(0,0,0))
        self.goal_island = Entity(model='cube', scale=(GOAL_SIZE,1,GOAL_SIZE),
                                  color=color.green, collider='box', position=(0,0.5,GOAL_Z))
        Entity(model='cube', color=color.gold, scale=(2,4,2), position=(0,2,GOAL_Z))
        Entity(model='cube', color=color.azure,
               scale=(1,0.3,1), position=(-2,0.2,20), collider='box')
        Entity(model='cube', color=color.red,
               scale=(1,0.3,1), position=(2,0.2,20), collider='box')
        self.player = Runner(PLAYER_LANE_X, color.azure, position=Vec3(PLAYER_LANE_X,1,-START_SIZE/4))
        self.bot = Bot(BOT_LANE_X, color.red, position=Vec3(BOT_LANE_X,1,-START_SIZE/4))
        camera.fov = 60
        camera.position = Vec3(0,25,-40)
        camera.rotation_x = 25
        self.collectables = []
        for _ in range(12): self.spawn_block()
        invoke(self.spawn_block, delay=SPAWN_INTERVAL)
        self.player_bridge, self.bot_bridge = [], []
        self.player_text = Text(text='You: 0', position=Vec2(-0.47,0.45))
        self.bot_text    = Text(text='Bot: 0',  position=Vec2(0.33,0.45))
        self.win_text = None
        # แสงอาทิตย์หลัก (Directional Light)
        sun = DirectionalLight(shadows=True)
        sun.look_at(Vec3(1, -1, -0.6))
        sun.color = color.rgb(255, 240, 220)   # โทนแสงอุ่นนุ่ม

        # แสงกระจายรอบฉาก (Ambient Light)
        ambient = AmbientLight()
        ambient.color = color.rgb(130, 130, 150)
        # ท้องฟ้า
        sky = Sky()



    def spawn_block(self):
        col = random.choice([color.azure, color.red])
        x = random.randint(-int(START_SIZE/2)+1, int(START_SIZE/2)-1)
        z = random.randint(-int(START_SIZE/2)+1, int(START_SIZE/2)-1)
        self.collectables.append(Entity(model='cube', color=col, scale=1, position=(x,BLOCK_Y,z), collider='box'))
        invoke(self.spawn_block, delay=SPAWN_INTERVAL)

    def try_pickup_blocks(self, r: Runner):
        for b in list(self.collectables):
            if b.color != r.color_main: continue
            if distance(r.position, b.position) < 1.4 and r.z <= GAP_START_Z + 0.01:
                self.collectables.remove(b); destroy(b); r.add_block(1); break

    def ensure_bridge(self, r: Runner, bridge_list: list):
        FIRST_Z = GAP_START_Z - 0.5
        if not (GAP_START_Z-2.0 <= r.z <= GAP_END_Z+0.6): return
        last_z = max([p.position.z for p in bridge_list], default=FIRST_Z - GRID)
        if r.inventory > 0:
            front_target = max(FIRST_Z, floor_snap(r.z, GRID)) + 0.5
            z = max(last_z, FIRST_Z) + GRID
            while z <= min(front_target, GAP_END_Z) and r.inventory > 0:
                step_idx = int(round((z - FIRST_Z)/GRID))
                y = BLOCK_Y + step_idx * STEP_RISE
                pos = Vec3(r.lane_x, y, z)
                exists = any(abs(e.position.x-pos.x)<0.05 and abs(e.position.z-pos.z)<0.05 for e in bridge_list)
                if not exists:
                    piece = Entity(model='cube', color=r.color_main.tint(-.15),
                                   scale=(1,0.3,1), position=pos, collider='box')
                    bridge_list.append(piece)
                    r.consume_block(1)
                    r.safe_z = z
                z += GRID
        if r.inventory == 0 and r.safe_z is not None and r.z > r.safe_z:
            r.z = r.safe_z
            r.vel_y = 0
        if bridge_list:
            last_piece = max(bridge_list, key=lambda e: e.position.z)
            if GAP_START_Z-0.6 <= r.z <= last_piece.z + 0.3:
                r.y = max(r.y, last_piece.y + 1)

    def reset_if_fall(self, r: Runner):
        if r.y < -7.5 and r.z < GAP_END_Z:
            r.position = Vec3(r.lane_x, 1, -START_SIZE/4)
            r.vel_y = 0

    def update(self):
        if self.win_text:
            self.player.finished = True
            self.bot.finished = True
            return
        self.player.physics_update(self.player.move_input())
        self.try_pickup_blocks(self.player)
        self.ensure_bridge(self.player, self.player_bridge)
        self.reset_if_fall(self.player)
        self.bot.physics_update(self.bot.ai_move(self))
        self.try_pickup_blocks(self.bot)
        self.ensure_bridge(self.bot, self.bot_bridge)
        self.reset_if_fall(self.bot)
        cam_target = self.player.position + Vec3(0,20,-30)
        camera.position = lerp(camera.position, cam_target, time.dt*3)
        camera.look_at(self.player.position + Vec3(0,4,0))
        self.player_text.text = f'You: {self.player.inventory}'
        self.bot_text.text    = f'Bot: {self.bot.inventory}'
        if not self.win_text:
            if distance(self.player.position, self.goal_island.position) < GOAL_SIZE/2:
                self.win_text = Text('YOU WIN!', origin=(0,0), scale=3, color=color.gold)
                self.player.finished = True
                self.bot.finished = True
                return
            elif self.bot.z >= GAP_END_Z - 0.3:
                self.win_text = Text('YOU LOSE!', origin=(0,0), scale=3, color=color.red)
                self.player.finished = True
                self.bot.finished = True
                self.bot.z = GAP_END_Z - 0.3
                return


# ===================== คัทซีนเริ่มเกม =====================
def start_cutscene():
    red_block = Entity(model='assets/models/player/red.obj',texture='textures/player/colormap.png',color=color.red, scale=(3.5), position=(-4,-1.5,2), rotation_y=-225)
    blue_block = Entity(model='assets/models/player/blue.obj',texture='textures/player/colormap.png', color=color.azure, scale=(3.5), position=(4,-1.5,2), rotation_y=225)
    start_button = Button(text='START', scale=(0.25,0.12), color=color.azure, y=0)
    def start_game():
        destroy(red_block)
        destroy(blue_block)
        destroy(start_button)
        BridgeRaceLevel()
    start_button.on_click = start_game

start_cutscene()
app.run()